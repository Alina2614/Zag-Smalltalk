'From Pharo13.0.0SNAPSHOT of 10 September 2024 [Build information: Pharo-13.0.0+SNAPSHOT.build.211.sha.aa904578282c5cc852fb02444e68eed1ab07e147 (64 Bit)] on 17 May 2025 at 1:04:58.452 am'!Object subclass: #BenchRandom	instanceVariableNames: ''	classVariableNames: ''	package: 'ZagBench-Benchmarking'!!BenchRandom commentStamp: '' prior: 0!I generate random integers in a repeatable way so that our "random" algorithms are repeatable.!!BenchRandom methodsFor: 'as yet unclassified' stamp: '4/19/2025 21:45'!randomSquare: anInteger	^ self randomWithRows: anInteger columns: anInteger! !!BenchRandom methodsFor: 'as yet unclassified' stamp: '4/19/2025 21:50'!makeInvertable	| matrix |	matrix withIndexDo: [ :row :index |		row			at: index			put: (row inject: 0 into: [ :sum :each | sum + each abs ]) ]! !!BenchRandom methodsFor: 'as yet unclassified' stamp: '4/19/2025 23:53'!LcgFloat	"|lcg |	lcg := BenchRandom new.	^ Array rows: 10 columns: 6 tabulate: [ :i :j | random next ]"	| randomArray size seed a c m currentValue rand lcg|BenchRandom class >> lcg .	^ self new initialize. 		size := 10. "Define the size of the array"	seed := 12345. "Choose an initial seed value"	a := 1103515245. "Multiplier constant"	c := 12345. "Increment constant"	m := 2 raisedTo: 31. "Modulus "	randomArray := OrderedCollection new. "Create an empty collection to store random numbers"	rand := seed. "Set the initial value to the seed"			rand := BenchRandom between: 0 and: 100.	"(1 to: 10) collect: [ :ignore | rand nextFloat ]."	1 to: size do: [ :i |		rand := a * rand + c \\ m. "Linear congruential generator formula"		randomArray add: rand / m * 100 ."Scale the result to a range between 0 and 100" ].	^ randomArray asArray "Return the array" 			! !!BenchRandom methodsFor: 'as yet unclassified' stamp: '5/1/2025 01:48'!createRowAndColumn	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	| random rows matrix cols|	random := Random new.	matrix := (1 to: rows) collect: [ :i |		          (1 to: cols) collect: [ :j | random next ] ].! !!BenchRandom methodsFor: 'accessing'!next	^ 0.5! !!BenchRandom methodsFor: 'accessing'!nextInteger: anInteger	"Answer a random integer in the interval [1, anInteger].	Handle large numbers too (for cryptography)."	anInteger strictlyPositive ifFalse: [		self error: 'Range must be positive' ].	^ (self next * anInteger) truncated	  + 1! !